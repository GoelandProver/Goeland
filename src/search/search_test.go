/**
* Copyright 2022 by the authors (see AUTHORS).
*
* GoÃ©land is an automated theorem prover for first order logic.
*
* This software is governed by the CeCILL license under French law and
* abiding by the rules of distribution of free software.  You can  use,
* modify and/ or redistribute the software under the terms of the CeCILL
* license as circulated by CEA, CNRS and INRIA at the following URL
* "http://www.cecill.info".
*
* As a counterpart to the access to the source code and  rights to copy,
* modify and redistribute granted by the license, users are provided only
* with a limited warranty  and the software's author,  the holder of the
* economic rights,  and the successive licensors  have only  limited
* liability.
*
* In this respect, the user's attention is drawn to the risks associated
* with loading,  using,  modifying and/or developing or reproducing the
* software by the user in light of its specific status of free software,
* that may mean  that it is complicated to manipulate,  and  that  also
* therefore means  that it is reserved for developers  and  experienced
* professionals having in-depth computer knowledge. Users are therefore
* encouraged to load and test the software's suitability as regards their
* requirements in conditions enabling the security of their systems and/or
* data to be ensured and,  more generally, to use and operate it in the
* same conditions as regards security.
*
* The fact that you are presently reading this means that you have had
* knowledge of the CeCILL license and that you accept its terms.
**/

/********************/
/*  search_test.go  */
/********************/

/**
 * This file tests the search package.
 **/

package search

import (
	"os"
	"testing"

	polymorphism "github.com/GoelandProver/Goeland/polymorphism/typing"
	syntax "github.com/GoelandProver/Goeland/syntaxic-manipulations"
	basictypes "github.com/GoelandProver/Goeland/types/basic-types"
)

func TestMain(m *testing.M) {
	polymorphism.Init()
	code := m.Run()
	os.Exit(code)
}

/* Tests Skolemization and instantiation */

/* 1 - Simple (untyped) tests */

func TestSimpleExistSkolemization(t *testing.T) {
	// exists x. P(x) ==> x should be a new constant expression
	x := basictypes.MakerVar("x")
	form := basictypes.MakeFormAndTerm(basictypes.MakerEx([]basictypes.Var{x}, basictypes.MakerPred(basictypes.MakerId("P"), basictypes.TermList{x}, []polymorphism.TypeApp{})), basictypes.MakeEmptyTermList())
	f := syntax.Skolemize(form, basictypes.MetaList{})

	if pred, ok := f.GetForm().(basictypes.Pred); ok {
		if len(pred.GetArgs()) > 1 {
			t.Errorf("Wrong number of predicate arguments on skolemization.")
		} else {
			arg := pred.GetArgs()[0]
			if fun, ok := arg.(basictypes.Fun); ok {
				if len(fun.GetArgs()) != 0 {
					t.Errorf("Wrong number of skolemized function arguments.")
				}
				if !fun.GetTypeHint().Equals(polymorphism.DefaultType()) {
					t.Errorf("Skolemized function is wrongely typed")
				}
			} else {
				t.Errorf("Skolemization didn't create a function.")
			}
		}
	} else {
		t.Errorf("Exist symbol not deleted on skolemization.")
	}
}

func TestSimpleNotForallSkolemization(t *testing.T) {
	// not(forall x. P(x)) ==> x should be a new constant expression
	x := basictypes.MakerVar("x")
	form := basictypes.MakeFormAndTerm(basictypes.MakerNot(basictypes.MakerAll([]basictypes.Var{x}, basictypes.MakerPred(basictypes.MakerId("P"), basictypes.TermList{x}, []polymorphism.TypeApp{}))), basictypes.MakeEmptyTermList())
	f := syntax.Skolemize(form, basictypes.MetaList{})

	if neg, ok := f.GetForm().(basictypes.Not); ok {
		if pred, ok := neg.GetForm().(basictypes.Pred); ok {
			if len(pred.GetArgs()) != 1 {
				t.Errorf("Wrong number of predicate arguments on skolemization.")
			} else {
				arg := pred.GetArgs()[0]
				if fun, ok := arg.(basictypes.Fun); ok {
					if len(fun.GetArgs()) != 0 {
						t.Errorf("Wrong number of skolemized function arguments.")
					}
					if !fun.GetTypeHint().Equals(polymorphism.DefaultType()) {
						t.Errorf("Skolemized function is wrongely typed")
					}
				} else {
					t.Errorf("Skolemization didn't create a function.")
				}
			}
		} else {
			t.Errorf("Predicate has not been negated on neg(forall P) skolemization.")
		}
	} else {
		t.Errorf("Forall symbol not deleted on skolemization.")
	}
}

func TestSimpleForallInstantiation(t *testing.T) {
	// forall x. P(x) ==> x should be a new meta
	x := basictypes.MakerVar("x")
	form := basictypes.MakeFormAndTerm(basictypes.MakerAll([]basictypes.Var{x}, basictypes.MakerPred(basictypes.MakerId("P"), basictypes.TermList{x}, []polymorphism.TypeApp{})), basictypes.MakeEmptyTermList())
	f, metas := syntax.Instantiate(form, 0)

	if len(metas) != 1 {
		t.Errorf("Wrong number of metas generated by instantiation function.")
	} else {
		if pred, ok := f.GetForm().(basictypes.Pred); ok {
			if len(pred.GetArgs()) != 1 {
				t.Errorf("Wrong number of predicate arguments on instantiation.")
			} else {
				arg := pred.GetArgs()[0]
				if meta, ok := arg.(basictypes.Meta); ok {
					if !meta.Equals(metas[0]) {
						t.Errorf("MetaList and generated meta is not the same on instantiation.")
					}
					if !meta.GetTypeHint().Equals(polymorphism.DefaultType()) {
						t.Errorf("Instantiated meta is wrongely typed")
					}
				} else {
					t.Errorf("Instantiation didn't create a meta in the arguments.")
				}
			}
		} else {
			t.Errorf("Forall symbol not deleted on instantiation.")
		}
	}
}

func TestSimpleNotExistsInstantiation(t *testing.T) {
	// neg(exists x. P(x)) ==> x should be a new meta
	x := basictypes.MakerVar("x")
	form := basictypes.MakeFormAndTerm(basictypes.MakerNot(basictypes.MakerEx([]basictypes.Var{x}, basictypes.MakerPred(basictypes.MakerId("P"), basictypes.TermList{x}, []polymorphism.TypeApp{}))), basictypes.MakeEmptyTermList())
	f, metas := syntax.Instantiate(form, 0)

	if len(metas) != 1 {
		t.Errorf("Wrong number of metas generated by instantiation function.")
	} else {
		if neg, ok := f.GetForm().(basictypes.Not); ok {
			if pred, ok := neg.GetForm().(basictypes.Pred); ok {
				if len(pred.GetArgs()) != 1 {
					t.Errorf("Wrong number of predicate arguments on instantiation.")
				} else {
					arg := pred.GetArgs()[0]
					if meta, ok := arg.(basictypes.Meta); ok {
						if !meta.Equals(metas[0]) {
							t.Errorf("MetaList and generated meta is not the same on instantiation.")
						}
						if !meta.GetTypeHint().Equals(polymorphism.DefaultType()) {
							t.Errorf("Instantiated meta is wrongely typed")
						}
					} else {
						t.Errorf("Instantiation didn't create a meta in the arguments.")
					}
				}
			} else {
				t.Errorf("Exists symbol not deleted on instantiation.")
			}
		} else {
			t.Errorf("Predicate has not been negated on neg(exists P) instantiation.")
		}
	}
}

/* 1 - Simple (typed) tests */

func TestSimpleTypedExistSkolemization(t *testing.T) {
	tInt := polymorphism.MkTypeHint("int")
	// exists x. P(x) ==> x should be a new constant expression
	x := basictypes.MakerVar("x", tInt)
	form := basictypes.MakeFormAndTerm(basictypes.MakerEx([]basictypes.Var{x}, basictypes.MakerPred(basictypes.MakerId("P"), basictypes.TermList{x}, []polymorphism.TypeApp{})), basictypes.MakeEmptyTermList())
	f := syntax.Skolemize(form, basictypes.MetaList{})

	if pred, ok := f.GetForm().(basictypes.Pred); ok {
		if len(pred.GetArgs()) != 1 {
			t.Errorf("Wrong number of predicate arguments on skolemization.")
		} else {
			arg := pred.GetArgs()[0]
			if fun, ok := arg.(basictypes.Fun); ok {
				if len(fun.GetArgs()) != 0 {
					t.Errorf("Wrong number of skolemized function arguments.")
				}
				if !fun.GetTypeHint().Equals(tInt) {
					t.Errorf("Skolemized function is wrongely typed")
				}
			} else {
				t.Errorf("Skolemization didn't create a function.")
			}
		}
	} else {
		t.Errorf("Exist symbol not deleted on skolemization.")
	}
}

func TestSimpleTypedNotForallSkolemization(t *testing.T) {
	tInt := polymorphism.MkTypeHint("int")
	// not(forall x. P(x)) ==> x should be a new constant expression
	x := basictypes.MakerVar("x", tInt)
	form := basictypes.MakeFormAndTerm(basictypes.MakerNot(basictypes.MakerAll([]basictypes.Var{x}, basictypes.MakerPred(basictypes.MakerId("P"), basictypes.TermList{x}, []polymorphism.TypeApp{}))), basictypes.MakeEmptyTermList())
	f := syntax.Skolemize(form, basictypes.MetaList{})

	if neg, ok := f.GetForm().(basictypes.Not); ok {
		if pred, ok := neg.GetForm().(basictypes.Pred); ok {
			if len(pred.GetArgs()) != 1 {
				t.Errorf("Wrong number of predicate arguments on skolemization.")
			} else {
				arg := pred.GetArgs()[0]
				if fun, ok := arg.(basictypes.Fun); ok {
					if len(fun.GetArgs()) != 0 {
						t.Errorf("Wrong number of skolemized function arguments.")
					}
					if !fun.GetTypeHint().Equals(tInt) {
						t.Errorf("Skolemized function is wrongely typed")
					}
				} else {
					t.Errorf("Skolemization didn't create a function.")
				}
			}
		} else {
			t.Errorf("Predicate has not been negated on neg(forall P) skolemization.")
		}
	} else {
		t.Errorf("Forall symbol not deleted on skolemization.")
	}
}

func TestSimpleTypedForallInstantiation(t *testing.T) {
	tInt := polymorphism.MkTypeHint("int")
	// forall x. P(x) ==> x should be a new meta
	x := basictypes.MakerVar("x", tInt)
	form := basictypes.MakeFormAndTerm(basictypes.MakerAll([]basictypes.Var{x}, basictypes.MakerPred(basictypes.MakerId("P"), basictypes.TermList{x}, []polymorphism.TypeApp{})), basictypes.MakeEmptyTermList())
	f, metas := syntax.Instantiate(form, 0)

	if len(metas) != 1 {
		t.Errorf("Wrong number of metas generated by instantiation function.")
	} else {
		if pred, ok := f.GetForm().(basictypes.Pred); ok {
			if len(pred.GetArgs()) != 1 {
				t.Errorf("Wrong number of predicate arguments on instantiation.")
			} else {
				arg := pred.GetArgs()[0]
				if meta, ok := arg.(basictypes.Meta); ok {
					if !meta.Equals(metas[0]) {
						t.Errorf("MetaList and generated meta is not the same on instantiation.")
					}
					if !meta.GetTypeHint().Equals(tInt) {
						t.Errorf("Instantiated meta is wrongely typed")
					}
				} else {
					t.Errorf("Instantiation didn't create a meta in the arguments.")
				}
			}
		} else {
			t.Errorf("Forall symbol not deleted on instantiation.")
		}
	}
}

func TestSimpleTypedNotExistsInstantiation(t *testing.T) {
	tInt := polymorphism.MkTypeHint("int")
	// neg(exists x. P(x)) ==> x should be a new meta
	x := basictypes.MakerVar("x", tInt)
	form := basictypes.MakeFormAndTerm(basictypes.MakerNot(basictypes.MakerEx([]basictypes.Var{x}, basictypes.MakerPred(basictypes.MakerId("P"), basictypes.TermList{x}, []polymorphism.TypeApp{}))), basictypes.MakeEmptyTermList())
	f, metas := syntax.Instantiate(form, 0)

	if len(metas) != 1 {
		t.Errorf("Wrong number of metas generated by instantiation function.")
	} else {
		if neg, ok := f.GetForm().(basictypes.Not); ok {
			if pred, ok := neg.GetForm().(basictypes.Pred); ok {
				if len(pred.GetArgs()) != 1 {
					t.Errorf("Wrong number of predicate arguments on instantiation.")
				} else {
					arg := pred.GetArgs()[0]
					if meta, ok := arg.(basictypes.Meta); ok {
						if !meta.Equals(metas[0]) {
							t.Errorf("MetaList and generated meta is not the same on instantiation.")
						}
						if !meta.GetTypeHint().Equals(tInt) {
							t.Errorf("Instantiated meta is wrongely typed")
						}
					} else {
						t.Errorf("Instantiation didn't create a meta in the arguments.")
					}
				}
			} else {
				t.Errorf("Exists symbol not deleted on instantiation.")
			}
		} else {
			t.Errorf("Predicate has not been negated on neg(exists P) instantiation.")
		}
	}
}

/* 3 - Full (untyped) formula */

func TestSyntaxicTransformationOnFormula(t *testing.T) {
	// Formula definition
	vars := []basictypes.Var{basictypes.MakerVar("x"), basictypes.MakerVar("y"), basictypes.MakerVar("z")}
	// forall x. P(x) => forall y. exists z.R(z, y)
	form := basictypes.MakeFormAndTerm(basictypes.MakerAll([]basictypes.Var{vars[0]}, basictypes.MakerImp(basictypes.MakerPred(basictypes.MakerId("P"), basictypes.TermList{vars[0]}, []polymorphism.TypeApp{}), basictypes.MakerAll([]basictypes.Var{vars[1]}, basictypes.MakerEx([]basictypes.Var{vars[2]}, basictypes.MakerPred(basictypes.MakerId("R"), basictypes.TermList{vars[2], vars[1]}, []polymorphism.TypeApp{}))))), basictypes.MakeEmptyTermList())

	// Instantiate x
	f1_inst, metas := syntax.Instantiate(form, 0)

	if pred, ok := f1_inst.GetForm().(basictypes.Pred); ok {
		if !pred.GetType().Equals(polymorphism.DefaultPropType(1)) {
			t.Errorf("Wrong default type for 1-arity predicate.")
		}
	}

	// Skolemize y & Instantiate z
	f2_inst, metas_2 := syntax.Instantiate(basictypes.MakeFormAndTerm(form.GetForm().(basictypes.All).GetForm().(basictypes.Imp).GetF2(), basictypes.MakeEmptyTermList()), 0)
	metas = append(metas, metas_2...)
	f2_sko := syntax.Skolemize(f2_inst, basictypes.MetaList{})

	if len(metas) != 2 {
		t.Errorf("Wrong amount of metas have been created")
	} else {
		if pred, ok := f2_sko.GetForm().(basictypes.Pred); ok {
			if !pred.GetType().Equals(polymorphism.MkTypeArrow(polymorphism.MkTypeCross(polymorphism.DefaultType(), polymorphism.DefaultType()), polymorphism.MkTypeHint("$o"))) {
				t.Errorf("Wrong type scheme for default predicate.")
			}
			// #0 is a function with 1 argument and #1 a meta
			if fun, ok := pred.GetArgs()[0].(basictypes.Fun); ok {
				if len(fun.GetArgs()) != 1 {
					t.Errorf("Skolemized argument should be a 1-arity function.")
				}
			} else {
				t.Errorf("Second argument should be a constant.")
			}
			if _, ok := pred.GetArgs()[1].(basictypes.Meta); !ok {
				t.Errorf("First argument should be a meta.")
			}
		} else {
			t.Errorf("Skolemization or instantiation failde.")
		}
	}
}

/* 3 - Full (typed) formula */
func TestSyntaxicTransformationOnTypedFormula(t *testing.T) {
	tInt := polymorphism.MkTypeHint("$int")
	tProp := polymorphism.MkTypeHint("$o")
	// Formula definition
	vars := []basictypes.Var{basictypes.MakerVar("x", tInt), basictypes.MakerVar("y", tInt), basictypes.MakerVar("z", tInt)}
	// forall x. P(x) => forall y. exists z.R(z, y)
	form := basictypes.MakeFormAndTerm(basictypes.MakerAll([]basictypes.Var{vars[0]}, basictypes.MakerImp(basictypes.MakerPred(basictypes.MakerId("P"), basictypes.TermList{vars[0]}, []polymorphism.TypeApp{}), basictypes.MakerAll([]basictypes.Var{vars[1]}, basictypes.MakerEx([]basictypes.Var{vars[2]}, basictypes.MakerPred(basictypes.MakerId("R"), basictypes.TermList{vars[2], vars[1]}, []polymorphism.TypeApp{}, polymorphism.MkTypeArrow(polymorphism.MkTypeCross(tInt, tInt), tProp)))))), basictypes.MakeEmptyTermList())

	// Instantiate x
	f1_inst, metas := syntax.Instantiate(form, 0)

	if pred, ok := f1_inst.GetForm().(basictypes.Pred); ok {
		if !pred.GetType().Equals(polymorphism.DefaultPropType(1)) {
			t.Errorf("Wrong default type for 1-arity predicate.")
		}
	}

	// Skolemize y & Instantiate z
	f2_inst, metas_2 := syntax.Instantiate(basictypes.MakeFormAndTerm(form.GetForm().(basictypes.All).GetForm().(basictypes.Imp).GetF2(), basictypes.MakeEmptyTermList()), 0)
	metas = append(metas, metas_2...)
	f2_sko := syntax.Skolemize(f2_inst, basictypes.MetaList{})

	if len(metas) != 2 {
		t.Errorf("Wrong amount of metas have been created")
	} else {
		if pred, ok := f2_sko.GetForm().(basictypes.Pred); ok {
			if !pred.GetType().Equals(polymorphism.MkTypeArrow(polymorphism.MkTypeCross(tInt, tInt), tProp)) {
				t.Errorf("Wrong type scheme for default predicate.")
			}
			// #0 is a function with 1 argument and #1 a meta
			if fun, ok := pred.GetArgs()[0].(basictypes.Fun); ok {
				if len(fun.GetArgs()) != 1 {
					t.Errorf("Skolemized argument should be a 1-arity function.")
				}
				if !fun.GetTypeHint().Equals(polymorphism.MkTypeArrow(tInt, tInt)) {
					t.Errorf("Wrongly inferred type in skolemization.")
				}
			} else {
				t.Errorf("Second argument should be a constant.")
			}
			if _, ok := pred.GetArgs()[1].(basictypes.Meta); !ok {
				t.Errorf("First argument should be a meta.")
			}
		} else {
			t.Errorf("Skolemization or instantiation failde.")
		}
	}
}

/*
	(X |-> Y ),
	(Z |-> f(Y, Y),
	(T |-> Y)
*/
func TestEliminate(t *testing.T) {
}
