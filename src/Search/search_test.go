/**
* Copyright 2022 by the authors (see AUTHORS).
*
* GoÃ©land is an automated theorem prover for first order logic.
*
* This software is governed by the CeCILL license under French law and
* abiding by the rules of distribution of free software.  You can  use,
* modify and/ or redistribute the software under the terms of the CeCILL
* license as circulated by CEA, CNRS and INRIA at the following URL
* "http://www.cecill.info".
*
* As a counterpart to the access to the source code and  rights to copy,
* modify and redistribute granted by the license, users are provided only
* with a limited warranty  and the software's author,  the holder of the
* economic rights,  and the successive licensors  have only  limited
* liability.
*
* In this respect, the user's attention is drawn to the risks associated
* with loading,  using,  modifying and/or developing or reproducing the
* software by the user in light of its specific status of free software,
* that may mean  that it is complicated to manipulate,  and  that  also
* therefore means  that it is reserved for developers  and  experienced
* professionals having in-depth computer knowledge. Users are therefore
* encouraged to load and test the software's suitability as regards their
* requirements in conditions enabling the security of their systems and/or
* data to be ensured and,  more generally, to use and operate it in the
* same conditions as regards security.
*
* The fact that you are presently reading this means that you have had
* knowledge of the CeCILL license and that you accept its terms.
**/

/**
 * This file tests the search package.
 **/

package Search

import (
	"os"
	"testing"

	"github.com/GoelandProver/Goeland/Core"
	"github.com/GoelandProver/Goeland/Typing"
)

func TestMain(m *testing.M) {
	polymorphism.Init()
	code := m.Run()
	os.Exit(code)
}

/* Tests Skolemization and instantiation */

/* 1 - Simple (untyped) tests */

func TestSimpleExistSkolemization(t *testing.T) {
	// exists x. P(x) ==> x should be a new constant expression
	x := Core.MakerVar("x")
	form := Core.MakeFormAndTerm(Core.MakerEx([]Core.Var{x}, Core.MakerPred(Core.MakerId("P"), Core.NewTermList(x), []polymorphism.TypeApp{})), Core.NewTermList())
	f := Core.Skolemize(form, Core.NewMetaList())

	if pred, ok := f.GetForm().(AST.Pred); ok {
		if pred.GetArgs().Len() > 1 {
			t.Errorf("Wrong number of predicate arguments on skolemization.")
		} else {
			arg := pred.GetArgs().Get(0)
			if fun, ok := arg.(Core.Fun); ok {
				if fun.GetArgs().Len() != 0 {
					t.Errorf("Wrong number of skolemized function arguments.")
				}
				if !fun.GetTypeHint().Equals(polymorphism.DefaultType()) {
					t.Errorf("Skolemized function is wrongely typed")
				}
			} else {
				t.Errorf("Skolemization didn't create a function.")
			}
		}
	} else {
		t.Errorf("Exist symbol not deleted on skolemization.")
	}
}

func TestSimpleNotForallSkolemization(t *testing.T) {
	// not(forall x. P(x)) ==> x should be a new constant expression
	x := Core.MakerVar("x")
	form := Core.MakeFormAndTerm(Core.MakerNot(Core.MakerAll([]Core.Var{x}, Core.MakerPred(Core.MakerId("P"), Core.NewTermList(x), []polymorphism.TypeApp{}))), Core.NewTermList())
	f := Core.Skolemize(form, Core.NewMetaList())

	if neg, ok := f.GetForm().(AST.Not); ok {
		if pred, ok := neg.GetForm().(AST.Pred); ok {
			if pred.GetArgs().Len() != 1 {
				t.Errorf("Wrong number of predicate arguments on skolemization.")
			} else {
				arg := pred.GetArgs().Get(0)
				if fun, ok := arg.(Core.Fun); ok {
					if fun.GetArgs().Len() != 0 {
						t.Errorf("Wrong number of skolemized function arguments.")
					}
					if !fun.GetTypeHint().Equals(polymorphism.DefaultType()) {
						t.Errorf("Skolemized function is wrongely typed")
					}
				} else {
					t.Errorf("Skolemization didn't create a function.")
				}
			}
		} else {
			t.Errorf("Predicate has not been negated on neg(forall P) skolemization.")
		}
	} else {
		t.Errorf("Forall symbol not deleted on skolemization.")
	}
}

func TestSimpleForallInstantiation(t *testing.T) {
	// forall x. P(x) ==> x should be a new meta
	x := Core.MakerVar("x")
	form := Core.MakeFormAndTerm(Core.MakerAll([]Core.Var{x}, Core.MakerPred(Core.MakerId("P"), Core.NewTermList(x), []polymorphism.TypeApp{})), Core.NewTermList())
	f, metas := Core.Instantiate(form, 0)

	if metas.Len() != 1 {
		t.Errorf("Wrong number of metas generated by instantiation function.")
	} else {
		if pred, ok := f.GetForm().(AST.Pred); ok {
			if pred.GetArgs().Len() != 1 {
				t.Errorf("Wrong number of predicate arguments on instantiation.")
			} else {
				arg := pred.GetArgs().Get(0)
				if meta, ok := arg.(Core.Meta); ok {
					if !meta.Equals(metas.Get(0)) {
						t.Errorf("MetaList and generated meta is not the same on instantiation.")
					}
					if !meta.GetTypeHint().Equals(polymorphism.DefaultType()) {
						t.Errorf("Instantiated meta is wrongely typed")
					}
				} else {
					t.Errorf("Instantiation didn't create a meta in the arguments.")
				}
			}
		} else {
			t.Errorf("Forall symbol not deleted on instantiation.")
		}
	}
}

func TestSimpleNotExistsInstantiation(t *testing.T) {
	// neg(exists x. P(x)) ==> x should be a new meta
	x := Core.MakerVar("x")
	form := Core.MakeFormAndTerm(Core.MakerNot(Core.MakerEx([]Core.Var{x}, Core.MakerPred(Core.MakerId("P"), Core.NewTermList(x), []polymorphism.TypeApp{}))), Core.NewTermList())
	f, metas := Core.Instantiate(form, 0)

	if metas.Len() != 1 {
		t.Errorf("Wrong number of metas generated by instantiation function.")
	} else {
		if neg, ok := f.GetForm().(AST.Not); ok {
			if pred, ok := neg.GetForm().(AST.Pred); ok {
				if pred.GetArgs().Len() != 1 {
					t.Errorf("Wrong number of predicate arguments on instantiation.")
				} else {
					arg := pred.GetArgs().Get(0)
					if meta, ok := arg.(Core.Meta); ok {
						if !meta.Equals(metas.Get(0)) {
							t.Errorf("MetaList and generated meta is not the same on instantiation.")
						}
						if !meta.GetTypeHint().Equals(polymorphism.DefaultType()) {
							t.Errorf("Instantiated meta is wrongely typed")
						}
					} else {
						t.Errorf("Instantiation didn't create a meta in the arguments.")
					}
				}
			} else {
				t.Errorf("Exists symbol not deleted on instantiation.")
			}
		} else {
			t.Errorf("Predicate has not been negated on neg(exists P) instantiation.")
		}
	}
}

/* 1 - Simple (typed) tests */

func TestSimpleTypedExistSkolemization(t *testing.T) {
	tInt := polymorphism.MkTypeHint("int")
	// exists x. P(x) ==> x should be a new constant expression
	x := Core.MakerVar("x", tInt)
	form := Core.MakeFormAndTerm(Core.MakerEx([]Core.Var{x}, Core.MakerPred(Core.MakerId("P"), Core.NewTermList(x), []polymorphism.TypeApp{})), Core.NewTermList())
	f := Core.Skolemize(form, Core.NewMetaList())

	if pred, ok := f.GetForm().(AST.Pred); ok {
		if pred.GetArgs().Len() != 1 {
			t.Errorf("Wrong number of predicate arguments on skolemization.")
		} else {
			arg := pred.GetArgs().Get(0)
			if fun, ok := arg.(Core.Fun); ok {
				if fun.GetArgs().Len() != 0 {
					t.Errorf("Wrong number of skolemized function arguments.")
				}
				if !fun.GetTypeHint().Equals(tInt) {
					t.Errorf("Skolemized function is wrongely typed")
				}
			} else {
				t.Errorf("Skolemization didn't create a function.")
			}
		}
	} else {
		t.Errorf("Exist symbol not deleted on skolemization.")
	}
}

func TestSimpleTypedNotForallSkolemization(t *testing.T) {
	tInt := polymorphism.MkTypeHint("int")
	// not(forall x. P(x)) ==> x should be a new constant expression
	x := Core.MakerVar("x", tInt)
	form := Core.MakeFormAndTerm(Core.MakerNot(Core.MakerAll([]Core.Var{x}, Core.MakerPred(Core.MakerId("P"), Core.NewTermList(x), []polymorphism.TypeApp{}))), Core.NewTermList())
	f := Core.Skolemize(form, Core.NewMetaList())

	if neg, ok := f.GetForm().(AST.Not); ok {
		if pred, ok := neg.GetForm().(AST.Pred); ok {
			if pred.GetArgs().Len() != 1 {
				t.Errorf("Wrong number of predicate arguments on skolemization.")
			} else {
				arg := pred.GetArgs().Get(0)
				if fun, ok := arg.(Core.Fun); ok {
					if fun.GetArgs().Len() != 0 {
						t.Errorf("Wrong number of skolemized function arguments.")
					}
					if !fun.GetTypeHint().Equals(tInt) {
						t.Errorf("Skolemized function is wrongely typed")
					}
				} else {
					t.Errorf("Skolemization didn't create a function.")
				}
			}
		} else {
			t.Errorf("Predicate has not been negated on neg(forall P) skolemization.")
		}
	} else {
		t.Errorf("Forall symbol not deleted on skolemization.")
	}
}

func TestSimpleTypedForallInstantiation(t *testing.T) {
	tInt := polymorphism.MkTypeHint("int")
	// forall x. P(x) ==> x should be a new meta
	x := Core.MakerVar("x", tInt)
	form := Core.MakeFormAndTerm(Core.MakerAll([]Core.Var{x}, Core.MakerPred(Core.MakerId("P"), Core.NewTermList(x), []polymorphism.TypeApp{})), Core.NewTermList())
	f, metas := Core.Instantiate(form, 0)

	if metas.Len() != 1 {
		t.Errorf("Wrong number of metas generated by instantiation function.")
	} else {
		if pred, ok := f.GetForm().(AST.Pred); ok {
			if pred.GetArgs().Len() != 1 {
				t.Errorf("Wrong number of predicate arguments on instantiation.")
			} else {
				arg := pred.GetArgs().Get(0)
				if meta, ok := arg.(Core.Meta); ok {
					if !meta.Equals(metas.Get(0)) {
						t.Errorf("MetaList and generated meta is not the same on instantiation.")
					}
					if !meta.GetTypeHint().Equals(tInt) {
						t.Errorf("Instantiated meta is wrongely typed")
					}
				} else {
					t.Errorf("Instantiation didn't create a meta in the arguments.")
				}
			}
		} else {
			t.Errorf("Forall symbol not deleted on instantiation.")
		}
	}
}

func TestSimpleTypedNotExistsInstantiation(t *testing.T) {
	tInt := polymorphism.MkTypeHint("int")
	// neg(exists x. P(x)) ==> x should be a new meta
	x := Core.MakerVar("x", tInt)
	form := Core.MakeFormAndTerm(Core.MakerNot(Core.MakerEx([]Core.Var{x}, Core.MakerPred(Core.MakerId("P"), Core.NewTermList(x), []polymorphism.TypeApp{}))), Core.NewTermList())
	f, metas := Core.Instantiate(form, 0)

	if metas.Len() != 1 {
		t.Errorf("Wrong number of metas generated by instantiation function.")
	} else {
		if neg, ok := f.GetForm().(AST.Not); ok {
			if pred, ok := neg.GetForm().(AST.Pred); ok {
				if pred.GetArgs().Len() != 1 {
					t.Errorf("Wrong number of predicate arguments on instantiation.")
				} else {
					arg := pred.GetArgs().Get(0)
					if meta, ok := arg.(Core.Meta); ok {
						if !meta.Equals(metas.Get(0)) {
							t.Errorf("MetaList and generated meta is not the same on instantiation.")
						}
						if !meta.GetTypeHint().Equals(tInt) {
							t.Errorf("Instantiated meta is wrongely typed")
						}
					} else {
						t.Errorf("Instantiation didn't create a meta in the arguments.")
					}
				}
			} else {
				t.Errorf("Exists symbol not deleted on instantiation.")
			}
		} else {
			t.Errorf("Predicate has not been negated on neg(exists P) instantiation.")
		}
	}
}

/* 3 - Full (untyped) formula */

func TestSyntaxicTransformationOnFormula(t *testing.T) {
	// Formula definition
	vars := []Core.Var{Core.MakerVar("x"), Core.MakerVar("y"), Core.MakerVar("z")}
	// forall x. P(x) => forall y. exists z.R(z, y)
	form := Core.MakeFormAndTerm(Core.MakerAll([]Core.Var{vars[0]}, Core.MakerImp(Core.MakerPred(Core.MakerId("P"), Core.NewTermList(vars[0]), []polymorphism.TypeApp{}), Core.MakerAll([]Core.Var{vars[1]}, Core.MakerEx([]Core.Var{vars[2]}, Core.MakerPred(Core.MakerId("R"), Core.NewTermList(vars[2], vars[1]), []polymorphism.TypeApp{}))))), Core.NewTermList())

	// Instantiate x
	f1_inst, metas := Core.Instantiate(form, 0)

	if pred, ok := f1_inst.GetForm().(AST.Pred); ok {
		if !pred.GetType().Equals(Typing.DefaultPropType(1)) {
			t.Errorf("Wrong default type for 1-arity predicate.")
		}
	}

	// Skolemize y & Instantiate z
	f2_inst, metas_2 := Core.Instantiate(Core.MakeFormAndTerm(form.GetForm().(AST.All).GetForm().(AST.Imp).GetF2(), Core.NewTermList()), 0)
	metas.AppendIfNotContains(metas_2.Slice()...)
	f2_sko := Core.Skolemize(f2_inst, Core.NewMetaList())

	if metas.Len() != 2 {
		t.Errorf("Wrong amount of metas have been created")
	} else {
		if pred, ok := f2_sko.GetForm().(AST.Pred); ok {
			if !pred.GetType().Equals(polymorphism.MkTypeArrow(polymorphism.MkTypeCross(polymorphism.DefaultType(), polymorphism.DefaultType()), polymorphism.MkTypeHint("$o"))) {
				t.Errorf("Wrong type scheme for default predicate.")
			}
			// #0 is a function with 1 argument and #1 a meta
			if fun, ok := pred.GetArgs().Get(0).(Core.Fun); ok {
				if fun.GetArgs().Len() != 1 {
					t.Errorf("Skolemized argument should be a 1-arity function.")
				}
			} else {
				t.Errorf("Second argument should be a constant.")
			}
			if _, ok := pred.GetArgs().Get(1).(Core.Meta); !ok {
				t.Errorf("First argument should be a meta.")
			}
		} else {
			t.Errorf("Skolemization or instantiation failde.")
		}
	}
}

/* 3 - Full (typed) formula */
func TestSyntaxicTransformationOnTypedFormula(t *testing.T) {
	tInt := polymorphism.MkTypeHint("$int")
	tProp := polymorphism.MkTypeHint("$o")
	// Formula definition
	vars := []Core.Var{Core.MakerVar("x", tInt), Core.MakerVar("y", tInt), Core.MakerVar("z", tInt)}
	// forall x. P(x) => forall y. exists z.R(z, y)
	form := Core.MakeFormAndTerm(Core.MakerAll([]Core.Var{vars[0]}, Core.MakerImp(Core.MakerPred(Core.MakerId("P"), Core.NewTermList(vars[0]), []polymorphism.TypeApp{}), Core.MakerAll([]Core.Var{vars[1]}, Core.MakerEx([]Core.Var{vars[2]}, Core.MakerPred(Core.MakerId("R"), Core.NewTermList(vars[2], vars[1]), []polymorphism.TypeApp{}, polymorphism.MkTypeArrow(polymorphism.MkTypeCross(tInt, tInt), tProp)))))), Core.NewTermList())

	// Instantiate x
	f1_inst, metas := Core.Instantiate(form, 0)

	if pred, ok := f1_inst.GetForm().(AST.Pred); ok {
		if !pred.GetType().Equals(polymorphism.DefaultPropType(1)) {
			t.Errorf("Wrong default type for 1-arity predicate.")
		}
	}

	// Skolemize y & Instantiate z
	f2_inst, metas_2 := Core.Instantiate(Core.MakeFormAndTerm(form.GetForm().(AST.All).GetForm().(AST.Imp).GetF2(), Core.NewTermList()), 0)
	metas.AppendIfNotContains(metas_2.Slice()...)
	f2_sko := Core.Skolemize(f2_inst, Core.NewMetaList())

	if metas.Len() != 2 {
		t.Errorf("Wrong amount of metas have been created")
	} else {
		if pred, ok := f2_sko.GetForm().(AST.Pred); ok {
			if !pred.GetType().Equals(polymorphism.MkTypeArrow(polymorphism.MkTypeCross(tInt, tInt), tProp)) {
				t.Errorf("Wrong type scheme for default predicate.")
			}
			// #0 is a function with 1 argument and #1 a meta
			if fun, ok := pred.GetArgs().Get(0).(Core.Fun); ok {
				if fun.GetArgs().Len() != 1 {
					t.Errorf("Skolemized argument should be a 1-arity function.")
				}
				if !fun.GetTypeHint().Equals(polymorphism.MkTypeArrow(tInt, tInt)) {
					t.Errorf("Wrongly inferred type in skolemization.")
				}
			} else {
				t.Errorf("Second argument should be a constant.")
			}
			if _, ok := pred.GetArgs().Get(1).(Core.Meta); !ok {
				t.Errorf("First argument should be a meta.")
			}
		} else {
			t.Errorf("Skolemization or instantiation failde.")
		}
	}
}
